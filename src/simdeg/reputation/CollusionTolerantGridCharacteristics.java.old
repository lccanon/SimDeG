package scheduling.reputation;

import com.LUT;

import scheduling.*;

import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.lang.reflect.Method;
import java.lang.Integer;
import java.lang.Double;
import java.lang.Math;

import flanagan.analysis.Stat;

/**
 * Strategy considering failures and collusions with a divergent behavior in
 * presence of strong adversity.
 */
public abstract class CollusionTolerantGridCharacteristics extends GridCharacteristics {

    /** Logger */
    private static final Logger logger
        = Logger.getLogger(CollusionTolerantGridCharacteristics.class
                .getName());

    /** Threshold below which a group is considering to not collude */
    private static final double COLLUSION_THRESHOLD = 0.01d;

    /** Minimum certainty under which an TooMuchUncertaintyException can be
     * thrown */
    private static final double MIN_CERTAINTY = 0.1d;

    /** Long term estimator standard deviation */
    private static final double LONG_TERM_STD_DEV = 0.03d;

    /** Short term estimator standard deviation */
    private static final double SHORT_TERM_STD_DEV = 0.1d;

    /**
     * Weight of the exponential long term moving average in order to have
     * a standard deviation equal to 0.01
     */
    private static final double LONG_TERM_WEIGHT
        = 8.0d * Math.pow(LONG_TERM_STD_DEV, 2.0d)
        / (4.0d * Math.pow(LONG_TERM_STD_DEV, 2.0d) + 1.0d);

    /**
     * Weight of the exponential short term moving average in order to have
     * a standard deviation equal to 0.1
     */
    private static final double SHORT_TERM_WEIGHT
        = 8.0d * Math.pow(SHORT_TERM_STD_DEV, 2.0d)
        / (4.0d * Math.pow(SHORT_TERM_STD_DEV, 2.0d) + 1.0d);

    private static final double LUT_PRECISION = 0.01d;

    private LUT<Double,Double> estimatorsConsistencyValues = null;

    /* XXX Optimization of this map (worker.hashcode and then array) */
    /** Long term estimators of the reliability */
    private Map<Worker,Double> reliabilityLong
        = new HashMap<Worker,Double>();

    /** Short term estimators of the reliability */
    private Map<Worker,Double> reliabilityShort
        = new HashMap<Worker,Double>();

    /** Long term estimators of the collusion likelihood */
    private Map<Worker,Map<Worker,Double>> collusionLong
        = new HashMap<Worker,Map<Worker,Double>>();

    /** Short term estimators of the collusion likelihood */
    private Map<Worker,Map<Worker,Double>> collusionShort
        = new HashMap<Worker,Map<Worker,Double>>();

    /** A Short term estimator of the certainty for smoothing */
    private double certainty = 0.0d;

    /**
     * Constructs the object and generates a LUT for fastening complex
     * computations.
     */
    public CollusionTolerantGridCharacteristics() {
        try {
            Method estimatorsConsistencyMethod
                = CollusionAwareGridCharacteristics.class.getMethod(
                        "getEstimatorsConsistency", Double.TYPE);
            estimatorsConsistencyValues = new LUT<Double,Double>(
                    estimatorsConsistencyMethod,
                    new Double[] {0.0d, 1.0d, LUT_PRECISION});
        } catch (NoSuchMethodException e) {
            logger.log(Level.SEVERE,
                    "The method getEstimatorsConsistency was not found", e);
            System.exit(1);
        }
    }

    /**
     * Gives participating workers.
     */
    protected void addAllWorkers(Set<? extends Worker> workers) {
        for (Worker worker : this.workers)
            for (Worker otherWorker : workers) {
                collusionLong.get(worker).put(otherWorker, 0.5d);
                collusionShort.get(worker).put(otherWorker, 0.0d);
            }
        super.addAllWorkers(workers);
        for (Worker worker : workers) {
            reliabilityLong.put(worker, 0.5d);
            reliabilityShort.put(worker, 1.0d);
            collusionLong.put(worker, new HashMap<Worker,Double>());
            collusionShort.put(worker, new HashMap<Worker,Double>());
            for (Worker otherWorker : this.workers) {
                collusionLong.get(worker).put(otherWorker, 0.5d);
                collusionShort.get(worker).put(otherWorker, 0.0d);
            }
        }
    }

    /**
     * Remove participating workers.
     */
    protected void removeAllWorkers(Set<? extends Worker> workers) {
        super.removeAllWorkers(workers);
        //TODO keep workers history
        for (Worker worker : workers) {
            reliabilityLong.remove(worker);
            reliabilityShort.remove(worker);
            collusionLong.remove(worker);
            collusionShort.remove(worker);
        }
    }

    /**
     * Specifies that some workers were found to give singleton answer.
     */
    void setFailure(Set<Worker> workers) {
        for (Worker worker : workers) {
            if (!this.workers.contains(worker))
                continue;
            reliabilityLong.put(worker, reliabilityLong.get(worker)
                    * (1.0d - LONG_TERM_WEIGHT));
            reliabilityShort.put(worker, reliabilityShort.get(worker)
                    * (1.0d - SHORT_TERM_WEIGHT));
        }
    }

    /**
     * Specifies that some workers give same kind of answer, hence success.
     */
    void setSuccess(Set<Worker> workers) {
        for (Worker worker : workers) {
            if (!this.workers.contains(worker))
                continue;
            reliabilityLong.put(worker, reliabilityLong.get(worker)
                    * (1.0d - LONG_TERM_WEIGHT) + LONG_TERM_WEIGHT);
            reliabilityShort.put(worker, reliabilityShort.get(worker)
                    * (1.0d - SHORT_TERM_WEIGHT) + SHORT_TERM_WEIGHT);
        }
    }

    private void increaseCollusion(Worker worker, Worker otherWorker) {
        collusionLong.get(worker).put(otherWorker, (1.0d - LONG_TERM_WEIGHT) *
                collusionLong.get(worker).get(otherWorker) + LONG_TERM_WEIGHT);
        collusionShort.get(worker).put(otherWorker, SHORT_TERM_WEIGHT +
                (1.0d - SHORT_TERM_WEIGHT)
                * collusionShort.get(worker).get(otherWorker));
    }

    private void decreaseCollusion(Worker worker, Worker otherWorker) {
        collusionLong.get(worker).put(otherWorker, (1.0d - LONG_TERM_WEIGHT) *
                collusionLong.get(worker).get(otherWorker));
        collusionShort.get(worker).put(otherWorker,
                (1.0d - SHORT_TERM_WEIGHT)
                * collusionShort.get(worker).get(otherWorker));
    }

    /**
     * Specifies that a worker disagrees with a set of workers.
     */
    void setDisagreement(Worker worker, Set<Worker> workers) {
        assert (!workers.isEmpty()) : "Not enough workers in groups";
        if (!this.workers.contains(worker))
            return;
        /* Non-observed collusion */
        for (Worker otherWorker : workers) {
            if (!this.workers.contains(otherWorker))
                continue;
            logger.fine("Worker " + worker
                    + " disagrees with worker " + otherWorker);
            decreaseCollusion(worker, otherWorker);
            decreaseCollusion(otherWorker, worker);
        }
    }

    /**
     * Specifies the winning group among all these groups of workers giving
     * distinct answers. Workers does not contain the winning set.
     */
    void setDistinctSet(Set<Worker> winningWorkers, Set<Set<Worker>> workers) {
        assert (!winningWorkers.isEmpty()) : "Not winning workers";
        /* Observed collusion */
        for (Set<Worker> workersSet : workers)
            for (Worker worker : workersSet)
                for (Worker otherWorker : workersSet) {
                    if (!this.workers.contains(worker)
                            || !this.workers.contains(otherWorker))
                        continue;
                    increaseCollusion(worker, otherWorker);
                    increaseCollusion(otherWorker, worker);
                }
        /* Non-colluders */
        for (Worker worker : winningWorkers)
            for (Worker otherWorker : winningWorkers) {
                if (!this.workers.contains(worker)
                        || !this.workers.contains(otherWorker))
                    continue;
                decreaseCollusion(worker, otherWorker);
                decreaseCollusion(otherWorker, worker);
            }
        logger.info(winningWorkers.size() + " non-colluder(s) and " +
            workers.size() + " set(s) of colluders");
    }

    private String collusionToString() {
        double sumReliability = 0.0d;
        for (Worker worker : reliabilityLong.keySet())
            sumReliability += 
                getEstimatorsConsistency(
                        reliabilityLong.get(worker),
                        reliabilityShort.get(worker));
        double sumCollusion = 0.0d;
        for (Worker worker : collusionLong.keySet())
            sumCollusion += getEstimatorsConsistency(
                    collusionLong.get(worker).get(worker),
                    collusionShort.get(worker).get(worker));

        Worker worker = workers.iterator().next();
        return worker + " " + reliabilityShort.get(worker)
            + " " + reliabilityLong.get(worker)
            + " " + collusionShort.get(worker).get(worker)
            + " " + collusionLong.get(worker).get(worker)
            + " " + (sumReliability/reliabilityLong.size())
            + " " + (sumCollusion/reliabilityLong.size());
/*
        String result = "";
        for (Worker worker : workers) {
            result += worker;
            for (Worker otherWorker : workers)
                result += " " + getEstimatorsConsistency(collusionShort
                        .get(worker).get(otherWorker),
                        collusionLong.get(worker).get(otherWorker));
            result += "\n";
        }
        return result;
*/
    }

    /**
     * Returns the estimated reliability of the worker.
     */
    public double getReliability(Worker worker)
        throws TooMuchUncertaintyException {
        assert(reliabilityLong.containsKey(worker)) : "Worker not intialized";
        if (getEstimatorsConsistency(reliabilityLong.get(worker),
                    reliabilityShort.get(worker)) < MIN_CERTAINTY)
            throw new TooMuchUncertaintyException();
        return reliabilityLong.get(worker);
    }

    /**
     * Returns the estimated likelihood that a given group of workers give the
     * same wrong answer. If only one is not a colluder, then it will return a
     * low probability.
     */
    public double getCollusionLikelihood(Set<Worker> workers)
            throws TooMuchUncertaintyException {
        if (workers.size() == 1) {
            final Worker worker = workers.iterator().next();
            assert(collusionLong.containsKey(worker)
                    && collusionLong.get(worker).containsKey(worker))
                : "Worker not intialized";
            if (getEstimatorsConsistency(collusionLong.get(worker).get(worker),
                        collusionShort.get(worker).get(worker)) < MIN_CERTAINTY)
                throw new TooMuchUncertaintyException();
            return collusionLong.get(worker).get(worker);
        }

        double result = Double.MAX_VALUE;
        double certainty = 0.0d;
        for (Worker worker : workers)
            for (Worker otherWorker : workers)
                if (worker != otherWorker) {
                    assert(collusionLong.containsKey(worker)
                            && collusionLong.get(worker).containsKey(
                                otherWorker)) : "Worker not intialized";
                    certainty += getEstimatorsConsistency(
                            collusionLong.get(worker).get(otherWorker),
                            collusionShort.get(worker).get(otherWorker));
                    result = Math.min(collusionLong.get(worker)
                            .get(otherWorker), result);
                    logger.fine("Estimated collusion likelihood of worker "
                            + worker + " with " + otherWorker + " is "
                            + collusionLong.get(worker).get(otherWorker));
                }
        certainty /= workers.size() * (workers.size() - 1);

        if (certainty < MIN_CERTAINTY)
            throw new TooMuchUncertaintyException();
        logger.info("Estimated collusion likelihood of " + workers.size()
                + " workers is " + result);
        return result;
    }

    private boolean isColluder(Worker worker)
            throws TooMuchUncertaintyException {
        if (getEstimatorsConsistency(collusionLong.get(worker).get(worker),
                    collusionShort.get(worker).get(worker)) < MIN_CERTAINTY)
            throw new TooMuchUncertaintyException();
        return collusionLong.get(worker).get(worker) > COLLUSION_THRESHOLD;
    }

    /**
     * Returns the estimated fraction of colluders (workers returning together
     * the same wrong answer).
     */
    public double getColludersFraction() throws TooMuchUncertaintyException {
        if (getCertainty() < MIN_CERTAINTY)
            throw new TooMuchUncertaintyException();
        double fraction = 0.0d;
        for (Worker worker : reliabilityLong.keySet())
            if (isColluder(worker))
                fraction += 1.0d;
        fraction /= reliabilityLong.size();
        logger.info("Estimated fraction of colluders: " + fraction);
        return fraction;
    }

    public static final double getEstimatorsConsistency(double delta) {
        final double result = 1.0d - Stat.erf(delta
                / (Math.sqrt(2.0d) * (SHORT_TERM_STD_DEV + LONG_TERM_STD_DEV)));
        return result;
    }

    private double getEstimatorsConsistency(double e1, double e2) {
        return estimatorsConsistencyValues.getValue(Math.abs(e1 - e2));
    }

    /**
     * Gives a measure of the certainty of the measured estimators
     * (between 0 and 1). It consists in the minimum mean of both
     * reliability and collusion consistency.
     */
    public double getCertainty() {
        if (reliabilityLong.size() == 0)
            return 0.0d;

        double sumReliability = 0.0d;
        for (Worker worker : reliabilityLong.keySet())
            sumReliability += getEstimatorsConsistency(
                    reliabilityLong.get(worker),
                    reliabilityShort.get(worker));
        double sumCollusion = 0.0d;
        for (Worker worker : collusionLong.keySet())
            sumCollusion += getEstimatorsConsistency(
                    collusionLong.get(worker).get(worker),
                    collusionShort.get(worker).get(worker));
        final double result = Math.min(sumReliability, sumCollusion)
            / reliabilityLong.size();

        certainty *= (1.0d - SHORT_TERM_WEIGHT);
        certainty += SHORT_TERM_WEIGHT * result;

        if (logger.isLoggable(Level.FINER))
            logger.finer(collusionToString());
        logger.info("Current certainty: " + certainty);
        return result;
    }

}
